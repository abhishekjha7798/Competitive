<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/snippets/LazySegmentTree.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/snippets/LazySegmentTree.java" />
              <option name="updatedContent" value="// Segment Tree with Lazy Propagation - For range updates and range queries&#10;public class LazySegmentTree {&#10;    int[] tree, lazy;&#10;    int n;&#10;    &#10;    LazySegmentTree(int[] arr) {&#10;        n = arr.length;&#10;        tree = new int[4 * n];&#10;        lazy = new int[4 * n];&#10;        build(arr, 0, 0, n - 1);&#10;    }&#10;    &#10;    void build(int[] arr, int node, int start, int end) {&#10;        if (start == end) {&#10;            tree[node] = arr[start];&#10;        } else {&#10;            int mid = (start + end) / 2;&#10;            build(arr, 2 * node + 1, start, mid);&#10;            build(arr, 2 * node + 2, mid + 1, end);&#10;            tree[node] = tree[2 * node + 1] + tree[2 * node + 2];&#10;        }&#10;    }&#10;    &#10;    void updateRange(int l, int r, int val) {&#10;        updateRange(0, 0, n - 1, l, r, val);&#10;    }&#10;    &#10;    void updateRange(int node, int start, int end, int l, int r, int val) {&#10;        if (lazy[node] != 0) {&#10;            tree[node] += (end - start + 1) * lazy[node];&#10;            if (start != end) {&#10;                lazy[2 * node + 1] += lazy[node];&#10;                lazy[2 * node + 2] += lazy[node];&#10;            }&#10;            lazy[node] = 0;&#10;        }&#10;        &#10;        if (start &gt; end || start &gt; r || end &lt; l) return;&#10;        &#10;        if (start &gt;= l &amp;&amp; end &lt;= r) {&#10;            tree[node] += (end - start + 1) * val;&#10;            if (start != end) {&#10;                lazy[2 * node + 1] += val;&#10;                lazy[2 * node + 2] += val;&#10;            }&#10;            return;&#10;        }&#10;        &#10;        int mid = (start + end) / 2;&#10;        updateRange(node * 2 + 1, start, mid, l, r, val);&#10;        updateRange(node * 2 + 2, mid + 1, end, l, r, val);&#10;        tree[node] = tree[2 * node + 1] + tree[2 * node + 2];&#10;    }&#10;    &#10;    long queryRange(int l, int r) {&#10;        return queryRange(0, 0, n - 1, l, r);&#10;    }&#10;    &#10;    long queryRange(int node, int start, int end, int l, int r) {&#10;        if (start &gt; end || start &gt; r || end &lt; l) return 0;&#10;        &#10;        if (lazy[node] != 0) {&#10;            tree[node] += (end - start + 1) * lazy[node];&#10;            if (start != end) {&#10;                lazy[2 * node + 1] += lazy[node];&#10;                lazy[2 * node + 2] += lazy[node];&#10;            }&#10;            lazy[node] = 0;&#10;        }&#10;        &#10;        if (start &gt;= l &amp;&amp; end &lt;= r) return tree[node];&#10;        &#10;        int mid = (start + end) / 2;&#10;        return queryRange(2 * node + 1, start, mid, l, r) +&#10;               queryRange(2 * node + 2, mid + 1, end, l, r);&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>