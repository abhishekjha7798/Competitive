/*
SEGMENTED SIEVE - DETAILED EXPLANATION WITH EXAMPLE
====================================================

Finding all primes in range [32, 76]

CODE LINE-BY-LINE BREAKDOWN:
============================

Line 1: long limit = (long) Math.sqrt(right) + 1;
        limit = sqrt(76) + 1 = 8 + 1 = 9

        WHY? We only need primes up to √right because:
        - Any composite number in [32, 76] must have a prime factor ≤ √76
        - If a number has no prime factor ≤ √76, it must be prime

        EXAMPLE: To check if 77 is prime, we only check divisibility by primes up to √77 ≈ 8.77

---

Line 2: boolean[] basePrimes = sieve((int) limit);
        basePrimes = sieve(9)

        This creates a boolean array with all primes up to 9:
        basePrimes[0] = false, basePrimes[1] = false
        basePrimes[2] = true,  basePrimes[3] = true
        basePrimes[4] = false, basePrimes[5] = true
        basePrimes[6] = false, basePrimes[7] = true
        basePrimes[8] = false, basePrimes[9] = false

        So base primes are: 2, 3, 5, 7

        WHY? These are the only primes we need to check against in our range

---

Line 3: boolean[] isPrime = new boolean[(int)(right - left + 1)];
        isPrime = new boolean[76 - 32 + 1]
        isPrime = new boolean[45]  // Array size 45 for range [32, 76]

        Array indices:    0    1    2    3  ...  44
        Actual numbers:  32   33   34   35  ... 76

        WHY? We create a smaller array to represent only our target range

---

Line 4: for (int i = 0; i < isPrime.length; i++) { isPrime[i] = true; }
        Initialize all 45 elements as TRUE (assume all are prime initially)

        isPrime = [T, T, T, T, T, T, T, T, T, T, ... T] (45 trues)

---

Line 5-9: Handle special case for 0 and 1
        if (left <= 1) { ... mark 0 and 1 as not prime ... }

        In our example: left = 32, so this block is SKIPPED
        (since 32 > 1, we don't need to handle 0 or 1)

---

Lines 10-18: MAIN LOGIC - Mark composites using base primes

        for (int i = 2; i <= limit; i++) {  // i = 2, 3, 5, 7
            if (basePrimes[i]) {  // Only process if i is prime

                // Step 1: Find first multiple of i in range [32, 76]
                long firstMultiple = ((left + i - 1) / i) * i;
                if (firstMultiple == i) firstMultiple += i;

                // Step 2: Mark all multiples of i as composite
                for (long j = firstMultiple; j <= right; j += i) {
                    isPrime[(int)(j - left)] = false;
                }
            }
        }

ITERATION BREAKDOWN:
====================

ITERATION 1: i = 2 (basePrimes[2] = true, so process it)

    Step 1a: Find first multiple of 2 in [32, 76]
             firstMultiple = ((32 + 2 - 1) / 2) * 2
                           = (33 / 2) * 2
                           = 16 * 2
                           = 32

    Step 1b: Check if firstMultiple == i
             32 == 2? NO, so skip the if block
             firstMultiple = 32

    Step 2: Mark all multiples of 2 from 32 to 76
            j = 32: isPrime[32-32] = isPrime[0] = false  (32 is composite)
            j = 34: isPrime[34-32] = isPrime[2] = false  (34 is composite)
            j = 36: isPrime[36-32] = isPrime[4] = false  (36 is composite)
            ... (mark 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76)

    After Iteration 1:
    isPrime = [F, T, F, T, F, T, F, T, F, T, F, T, F, T, F, T, F, T, F, T, F, T, F, T, F, T, F, T, F, T, F, T, F, T, F, T, F, T, F, T, F, T, F, T, F]
    Indices:   0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44
    Numbers:  32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76

---

ITERATION 2: i = 3 (basePrimes[3] = true, so process it)

    Step 1a: Find first multiple of 3 in [32, 76]
             firstMultiple = ((32 + 3 - 1) / 3) * 3
                           = (34 / 3) * 3
                           = 11 * 3
                           = 33

    Step 1b: Check if firstMultiple == i
             33 == 3? NO, so skip
             firstMultiple = 33

    Step 2: Mark all multiples of 3 from 33 to 76
            j = 33: isPrime[33-32] = isPrime[1] = false  (33 = 3×11, composite)
            j = 36: isPrime[36-32] = isPrime[4] = false  (already marked, 36 = 2×18)
            j = 39: isPrime[39-32] = isPrime[7] = false  (39 = 3×13, composite)
            ... (mark 42, 45, 48, 51, 54, 57, 60, 63, 66, 69, 72, 75)

    After Iteration 2:
    isPrime = [F, F, F, T, F, T, F, F, F, T, F, T, F, F, F, T, F, T, F, F, F, T, F, F, F, T, F, F, F, T, F, T, F, F, F, T, F, F, F, T, F, T, F, F, F]
    Numbers:  32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76

---

ITERATION 3: i = 5 (basePrimes[5] = true, so process it)

    Step 1a: Find first multiple of 5 in [32, 76]
             firstMultiple = ((32 + 5 - 1) / 5) * 5
                           = (36 / 5) * 5
                           = 7 * 5
                           = 35

    Step 1b: Check if firstMultiple == i
             35 == 5? NO, so skip
             firstMultiple = 35

    Step 2: Mark all multiples of 5 from 35 to 76
            j = 35: isPrime[35-32] = isPrime[3] = false  (35 = 5×7, composite)
            j = 40: isPrime[40-32] = isPrime[8] = false  (40 = 5×8, composite)
            j = 45: isPrime[45-32] = isPrime[13] = false (45 = 5×9, composite)
            ... (mark 50, 55, 60, 65, 70, 75)

    After Iteration 3:
    isPrime = [F, F, F, F, F, T, F, F, F, T, F, T, F, F, F, F, F, T, F, F, F, T, F, F, F, F, F, F, F, T, F, T, F, F, F, F, F, F, F, T, F, T, F, F, F]
    Numbers:  32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76

---

ITERATION 4: i = 7 (basePrimes[7] = true, so process it)

    Step 1a: Find first multiple of 7 in [32, 76]
             firstMultiple = ((32 + 7 - 1) / 7) * 7
                           = (38 / 7) * 7
                           = 5 * 7
                           = 35

    Step 1b: Check if firstMultiple == i
             35 == 7? NO, so skip
             firstMultiple = 35

    Step 2: Mark all multiples of 7 from 35 to 76
            j = 35: isPrime[35-32] = isPrime[3] = false  (35 = 7×5, already marked)
            j = 42: isPrime[42-32] = isPrime[10] = false (42 = 7×6, composite)
            j = 49: isPrime[49-32] = isPrime[17] = false (49 = 7×7, composite)
            j = 56: isPrime[56-32] = isPrime[24] = false (56 = 7×8, composite)
            j = 63: isPrime[63-32] = isPrime[31] = false (63 = 7×9, composite) ✓
            j = 70: isPrime[70-32] = isPrime[38] = false (70 = 7×10, composite)

    After Iteration 4:
    isPrime = [F, F, F, F, F, T, F, F, F, T, F, T, F, F, F, F, F, T, F, F, F, T, F, F, F, F, F, F, F, T, F, F, F, F, F, F, F, F, F, T, F, T, F, F, F]
    Numbers:  32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76

---

FINAL RESULT:
=============

isPrime array (indices and their corresponding numbers):
Index:  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44
Value:  F  F  F  F  F  T  F  F  F  T  F  T  F  F  F  T  F  T  F  F  F  T  F  F  F  F  F  F  F  T  F  F  F  F  F  T  F  F  F  T  F  T  F  F  F
Number:32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76

✓ CORRECT PRIMES IN [32, 76]:
37 (index 5)
41 (index 9)
43 (index 11)
47 (index 17)
53 (index 21)
61 (index 29)
67 (index 35)
71 (index 39)
73 (index 41)

Primes: 37, 41, 43, 47, 53, 61, 67, 71, 73

---

KEY INSIGHTS:
=============

1. WHY "((left + i - 1) / i) * i"?
   This formula finds the FIRST multiple of i that is >= left

   Example with i=3, left=32:
   (32 + 3 - 1) / 3 = 34/3 = 11 (integer division)
   11 * 3 = 33 ✓ (first multiple of 3 that is ≥ 32)

2. WHY "if (firstMultiple == i) firstMultiple += i"?
   If the first multiple happens to be the prime itself (i.e., the prime is in our range),
   we skip it because we only want to mark COMPOSITES, not the prime itself.

   Example: If range was [2, 10], firstMultiple would be 2, which is prime itself,
   so we'd skip marking 2 as composite and move to 4, 6, 8, 10.

3. Memory Efficiency:
   Regular sieve for range [32, 76]: needs array of size 77
   Segmented sieve: needs only array of size 45

   For range [10^9, 10^9 + 10^6]:
   Regular sieve: impossible (too large)
   Segmented sieve: only needs array of size 10^6 ✓

*/

